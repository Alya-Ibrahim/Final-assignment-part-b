# -*- coding: utf-8 -*-
"""part b-3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13xYlBeKNmipUJr5tLLy2uH3xHqOTXtoU
"""

import heapq  # heapq is a priority queue algorithm, also known as the heap queue algorithm.

# Intersection represents a node in the graph
class Intersection:
    def __init__(self, intersection_id):
        self.intersection_id = intersection_id  # Each intersection is identified by a unique ID
        self.adjacent_roads = []  # A list to keep track of all roads leading out of this intersection

    # Method to add a road to the intersection
    def add_road(self, road):
        self.adjacent_roads.append(road)  # Append the road to the list of adjacent roads

# Road represents an edge in the graph
class Road:
    def __init__(self, road_id, name, length, start_intersection, end_intersection):
        self.road_id = road_id  # Unique identifier for the road
        self.name = name  # Human-readable name for the road
        self.length = length  # Length of the road could be used to represent weight (e.g., travel time)
        self.start_intersection = start_intersection  # Reference to the starting intersection object
        self.end_intersection = end_intersection  # Reference to the ending intersection object

# TrafficGraph represents the entire road network as a graph
class TrafficGraph:
    def __init__(self):
        self.intersections = {}  # Stores all intersections in the graph
        self.roads = {}  # Stores all roads in the graph

    # Method to add an intersection to the graph
    def add_intersection(self, intersection_id):
        # Add an intersection only if it does not already exist
        if intersection_id not in self.intersections:
            self.intersections[intersection_id] = Intersection(intersection_id)

    # Method to add a road to the graph
    def add_road(self, road_id, name, length, start_id, end_id):
        # Ensure start and end intersections exist before adding the road
        if start_id not in self.intersections:
            self.add_intersection(start_id)
        if end_id not in self.intersections:
            self.add_intersection(end_id)

        # Get start and end intersection objects
        start_intersection = self.intersections[start_id]
        end_intersection = self.intersections[end_id]

        # Create a Road object
        road = Road(road_id, name, length, start_intersection, end_intersection)

        # Add road to both start and end intersections to allow bidirectional travel
        start_intersection.add_road(road)
        end_intersection.add_road(road)

        # Add the road to the graph's collection of roads
        self.roads[road_id] = road

    # Dijkstra's algorithm for finding the shortest path between two intersections
    def dijkstra(self, start_id, end_id):
        # Initialize all distances as infinity to represent that nodes are initially unreachable
        distances = {intersection: float('infinity') for intersection in self.intersections}
        # Set the distance from the start node to itself as 0
        distances[start_id] = 0

        # Use a priority queue to store and retrieve nodes to visit based on the shortest distance
        priority_queue = [(0, start_id)]
        previous = {}  # Stores the path taken to reach each node

        while priority_queue:
            # Pop the node with the shortest distance from the queue
            current_distance, current_vertex = heapq.heappop(priority_queue)
            # If we found a better path already, ignore this longer path
            if current_distance > distances[current_vertex]:
                continue

            # Explore each road connected to the current node
            for road in self.intersections[current_vertex].adjacent_roads:
                # Find the neighboring intersection
                neighbor = road.end_intersection.intersection_id
                # Calculate new distance through the current node
                weight = road.length
                distance = current_distance + weight

                # If the new distance is shorter, update and push it onto the priority queue
                if distance < distances[neighbor]:
                    distances[neighbor] = distance
                    previous[neighbor] = current_vertex
                    heapq.heappush(priority_queue, (distance, neighbor))

        # Reconstruct the shortest path from end to start by following the 'previous' pointers
        path = []
        step = end_id
        while step != start_id:
            path.insert(0, step)  # Insert the step at the beginning of the path list
            step = previous.get(step)  # Move to the next step in the path
        path.insert(0, start_id)  # Add the start node to the beginning of the path

        return distances[end_id], path  # Return the total distance and path found

    # Utility method to display the graph for debugging and verification purposes
    def display_graph(self):
        # Loop through all intersections and print their details
        for intersection in self.intersections.values():
            print(f"Intersection ID: {intersection.intersection_id}")
            # For each intersection, print details of its adjacent roads
            for road in intersection.adjacent_roads:
                print(f"  Road ID: {road.road_id}, Name: {road.name}, Length: {road.length}, Connects to: {road.end_intersection.intersection_id}")