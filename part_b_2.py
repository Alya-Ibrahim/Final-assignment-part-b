# -*- coding: utf-8 -*-
"""part b-2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18PBzkzYaOxpE0DyLDRyBcJVHu7nSuZgr
"""

import heapq

# Class to represent a house in the traffic graph
class House:
    def __init__(self, house_id, intersection_id):
        self.house_id = house_id  # Unique identifier for the house
        self.intersection_id = intersection_id  # ID of the intersection where the house is located

# Class to represent an intersection (node) in the graph
class Intersection:
    def __init__(self, intersection_id):
        self.intersection_id = intersection_id  # Unique identifier for the intersection
        self.adjacent_roads = []  # List to store all roads (edges) leading out of the intersection
        self.houses = []  # List to store houses associated with this intersection

    # Method to add a road to the intersection's list of roads
    def add_road(self, road):
        self.adjacent_roads.append(road)

    # Method to add a house to the intersection's list of houses
    def add_house(self, house):
        self.houses.append(house)

# Class to represent a road in the traffic graph
class Road:
    def __init__(self, road_id, name, length, start_intersection, end_intersection):
        self.road_id = road_id  # Unique identifier for the road
        self.name = name  # Human-readable name of the road
        self.length = length  # Length of the road, which may represent the cost or weight for traversal
        self.start_intersection = start_intersection  # Reference to the starting intersection object
        self.end_intersection = end_intersection  # Reference to the ending intersection object

# Class to manage the traffic graph
class TrafficGraph:
    def __init__(self):
        self.intersections = {}  # Dictionary to hold intersections by their IDs
        self.roads = {}  # Dictionary to hold roads by their IDs

    # Method to add an intersection to the graph
    def add_intersection(self, intersection_id):
        if intersection_id not in self.intersections:
            self.intersections[intersection_id] = Intersection(intersection_id)

    # Method to add a road to the graph
    def add_road(self, road_id, name, length, start_id, end_id):
        # Ensure both the start and end intersections exist
        if start_id not in self.intersections:
            self.add_intersection(start_id)
        if end_id not in self.intersections:
            self.add_intersection(end_id)
        # Get the intersection objects for the start and end
        start_intersection = self.intersections[start_id]
        end_intersection = self.intersections[end_id]
        # Create a new Road object connecting the two intersections
        road = Road(road_id, name, length, start_intersection, end_intersection)
        # Add the road to both intersections' road lists to account for bidirectionality
        start_intersection.add_road(road)
        end_intersection.add_road(road)
        # Add the road to the graph's road dictionary
        self.roads[road_id] = road

    # Method to add a house to an intersection
    def add_house_to_intersection(self, house_id, intersection_id):
        # Create a new House object
        house = House(house_id, intersection_id)
        # Add the house to the appropriate intersection's list of houses
        self.intersections[intersection_id].add_house(house)

    # Dijkstra's algorithm to find the shortest path between two intersections
    def dijkstra(self, start_id, end_id):
        # Initialize all distances to infinity
        distances = {node: float('infinity') for node in self.intersections}
        # Set the distance to the start intersection as zero
        distances[start_id] = 0
        # Priority queue to store intersections for exploration
        priority_queue = [(0, start_id)]
        # Dictionary to store the shortest path tree
        previous = {}

        while priority_queue:
            # Pop the intersection with the smallest distance from the queue
            current_distance, current_vertex = heapq.heappop(priority_queue)
            # Skip if a shorter path to this intersection has been found
            if current_distance > distances[current_vertex]:
                continue

            # Update the distance for each neighboring intersection
            for road in self.intersections[current_vertex].adjacent_roads:
                neighbor = road.end_intersection.intersection_id
                weight = road.length
                distance = current_distance + weight
                # If the new distance is shorter, update and push to the priority queue
                if distance < distances[neighbor]:
                    distances[neighbor] = distance
                    previous[neighbor] = current_vertex
                    heapq.heappush(priority_queue, (distance, neighbor))

        # Reconstruct the shortest path from end to start
        path = []
        step = end_id
        while step != start_id:
            path.insert(0, step)
            step = previous.get(step)
        path.insert(0, start_id)

        # Return the distance and the path
        return distances[end_id], path

    # Method to display the graph's data for verification
    def display_graph(self):
        # Loop through all intersections and print their roads and houses
        for intersection in self.intersections.values():
            print(f"Intersection ID: {intersection.intersection_id}")
            # Print all roads connected to the intersection
            for road in intersection.adjacent_roads:
                print(f"  Road ID: {road.road_id}, Name: {road.name}, Length: {road.length}, Connects to: {road.end_intersection.intersection_id}")
            # Print all houses associated with the intersection
            for house in intersection.houses:
                print(f"  House ID: {house.house_id}, Located at: {house.intersection_id}")